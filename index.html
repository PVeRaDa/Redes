<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Control LED (MQTT)</title>
  <style>
    body { font-family: sans-serif; max-width: 520px; margin: auto; padding: 16px; text-align: center; }
    button { padding: 12px 16px; margin: 8px; font-size: 16px; border-radius: 8px; cursor: pointer; }
    #status { margin-bottom: 12px; font-weight: bold; }
    #log { text-align: left; border: 1px solid #ddd; padding: 10px; height: 220px; overflow: auto; border-radius: 8px; background:#fafafa; }
    .ts { color:#666; font-size:12px; }
    .ok { color:green; }
    .err { color:red; }
    .msg { color:#333; }
    .warn { color: orange; }
  </style>
</head>
<body>
  <h2>ESP32 LED por MQTT</h2>
  <div id="status">Cargando librería MQTT...</div>

  <p>
    <button id="btnOn" disabled>Encender</button>
    <button id="btnOff" disabled>Apagar</button>
    <button id="btnToggle" disabled>Toggle</button>
  </p>

  <p>Estado del LED: <span id="ledState">?</span></p>

  <h3>Logs</h3>
  <div id="log"></div>

  <script>
    // === Configuración MQTT ===
    const HOST = "broker.hivemq.com";
    const PORT = 8080;  // WebSocket sin SSL
    const PATH = "/mqtt";
    const USE_SSL = false;

    // Topics (coinciden con tu ESP32)
    const TOPIC_CMD   = "pedro/esp32/led/cmd";
    const TOPIC_STATE = "pedro/esp32/led/state";
    const TOPIC_AVAIL = "pedro/esp32/led/availability";

    // Variables globales
    let client = null;
    let pahoLoaded = false;

    // Helpers de UI
    const $ = (id) => document.getElementById(id);
    const log = (html, cls = "msg") => {
      const ts = new Date().toLocaleTimeString();
      $("log").insertAdjacentHTML("afterbegin", `<div class="${cls}"><span class="ts">[${ts}]</span> ${html}</div>`);
    };

    // Habilitar/deshabilitar botones
    function setButtonsEnabled(enabled) {
      $("btnOn").disabled = !enabled;
      $("btnOff").disabled = !enabled;
      $("btnToggle").disabled = !enabled;
    }

    // Cargar Paho MQTT con múltiples fallbacks
    function loadPahoMQTT() {
      return new Promise((resolve, reject) => {
        // Si ya está cargado, resolver inmediatamente
        if (typeof Paho !== 'undefined' && Paho.MQTT && Paho.MQTT.Client) {
          log("Paho MQTT ya cargado", "ok");
          resolve();
          return;
        }

        const cdns = [
          'https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.1.0/mqttws31.min.js',
          'https://unpkg.com/paho-mqtt@1.1.0/paho-mqtt.min.js',
          'https://cdn.jsdelivr.net/npm/paho-mqtt@1.1.0/paho-mqtt.min.js'
        ];

        let currentCdn = 0;

        function tryLoad() {
          if (currentCdn >= cdns.length) {
            reject(new Error("Todos los CDNs fallaron"));
            return;
          }

          const script = document.createElement('script');
          script.src = cdns[currentCdn];
          
          script.onload = () => {
            // Verificar que Paho se cargó correctamente
            setTimeout(() => {
              if (typeof Paho !== 'undefined' && Paho.MQTT && Paho.MQTT.Client) {
                log(`Paho MQTT cargado desde: ${cdns[currentCdn]}`, "ok");
                resolve();
              } else {
                log(`CDN cargó pero Paho no está definido: ${cdns[currentCdn]}`, "warn");
                currentCdn++;
                tryLoad();
              }
            }, 100);
          };

          script.onerror = () => {
            log(`Error cargando: ${cdns[currentCdn]}`, "warn");
            currentCdn++;
            tryLoad();
          };

          document.head.appendChild(script);
        }

        tryLoad();
      });
    }

    // Inicializar aplicación MQTT
    function initMQTT() {
      if (typeof Paho === 'undefined' || !Paho.MQTT || !Paho.MQTT.Client) {
        log("ERROR: Paho MQTT no disponible después de cargar", "err");
        return;
      }

      try {
        // Crear cliente
        const clientId = "webclient-" + Math.random().toString(16).slice(2);
        client = new Paho.MQTT.Client(HOST, Number(PORT), PATH, clientId);
        
        log("Cliente MQTT creado correctamente", "ok");
        pahoLoaded = true;
        setButtonsEnabled(true);

        // Configurar event handlers
        client.onConnectionLost = onConnectionLost;
        client.onMessageArrived = onMessageArrived;

        // Conectar
        connectMQTT();

      } catch (error) {
        log(`Error creando cliente MQTT: ${error.message}`, "err");
      }
    }

    // Manejar pérdida de conexión
    function onConnectionLost(response) {
      $("status").textContent = "Desconectado";
      $("status").className = "err";
      log("Conexión perdida: " + (response.errorMessage || "Sin detalles"), "err");
      setButtonsEnabled(false);
      
      // Reconectar después de 3 segundos
      setTimeout(connectMQTT, 3000);
    }

    // Manejar mensajes entrantes
    function onMessageArrived(message) {
      const topic = message.destinationName;
      const payload = (message.payloadString || "").toLowerCase().trim();
      
      log(`RX <b>${topic}</b> = <code>${payload}</code>`);
      
      if (topic === TOPIC_STATE) {
        $("ledState").textContent = payload === "on" ? "ENCENDIDO" : "APAGADO";
        $("ledState").style.color = payload === "on" ? "green" : "gray";
      }
      
      if (topic === TOPIC_AVAIL) {
        log(`Disponibilidad ESP32: <b>${payload}</b>`);
      }
    }

    // Conectar al broker MQTT
    function connectMQTT() {
      if (!client) {
        log("Cliente no inicializado", "err");
        return;
      }

      $("status").textContent = "Conectando...";
      $("status").className = "";
      
      log(`Conectando a ${HOST}:${PORT} (WebSocket)`);

      const connectOptions = {
        timeout: 10,
        useSSL: USE_SSL,
        mqttVersion: 4, // MQTT 3.1.1
        keepAliveInterval: 60,
        cleanSession: true,
        onSuccess: onConnectSuccess,
        onFailure: onConnectFailure
      };

      client.connect(connectOptions);
    }

    function onConnectSuccess() {
      $("status").textContent = "Conectado a HiveMQ";
      $("status").className = "ok";
      log("Conexión MQTT exitosa ✅", "ok");
      
      // Suscribirse a topics
      client.subscribe(TOPIC_STATE, { qos: 0 });
      client.subscribe(TOPIC_AVAIL, { qos: 0 });
      log(`Suscrito a: <b>${TOPIC_STATE}</b> y <b>${TOPIC_AVAIL}</b>`);
      
      setButtonsEnabled(true);
    }

    function onConnectFailure(error) {
      $("status").textContent = "Error de conexión";
      $("status").className = "err";
      log(`Error conectando: ${error.errorMessage}`, "err");
      setButtonsEnabled(false);
      
      // Reintentar después de 5 segundos
      setTimeout(connectMQTT, 5000);
    }

    // Publicar comandos
    function publishCmd(cmd) {
      if (!client || !client.isConnected()) {
        log("No conectado. No se puede enviar comando.", "err");
        return;
      }

      try {
        const message = new Paho.MQTT.Message(cmd);
        message.destinationName = TOPIC_CMD;
        message.qos = 0;
        message.retained = false;
        
        client.send(message);
        log(`TX <b>${TOPIC_CMD}</b> = <code>${cmd}</code>`);
      } catch (error) {
        log(`Error enviando comando: ${error.message}`, "err");
      }
    }

    // Configurar event listeners para botones
    function setupEventListeners() {
      $("btnOn").onclick = () => publishCmd("on");
      $("btnOff").onclick = () => publishCmd("off");
      $("btnToggle").onclick = () => publishCmd("toggle");
    }

    // Inicializar la aplicación cuando se carga la página
    window.addEventListener('DOMContentLoaded', async function() {
      log("Iniciando aplicación...", "msg");
      setupEventListeners();
      setButtonsEnabled(false);

      try {
        await loadPahoMQTT();
        initMQTT();
      } catch (error) {
        log(`Error crítico: ${error.message}`, "err");
        $("status").textContent = "Error cargando librerías";
        $("status").className = "err";
        
        // Último intento - usar una versión local si está disponible
        log("Intentando cargar versión local de Paho...", "warn");
        const localScript = document.createElement('script');
        localScript.src = 'paho-mqtt.js'; // Archivo local
        localScript.onload = initMQTT;
        localScript.onerror = () => log("Versión local tampoco disponible", "err");
        document.head.appendChild(localScript);
      }
    });

    // Manejar reconexión cuando la página gana foco
    window.addEventListener('focus', function() {
      if (client && !client.isConnected() && pahoLoaded) {
        log("Página en foco - reconectando...", "warn");
        connectMQTT();
      }
    });
  </script>
</body>
</html>